
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/alxrusinov/shorturl/internal/app/app.go (0.0%)</option>
				
				<option value="file1">github.com/alxrusinov/shorturl/internal/config/config.go (86.2%)</option>
				
				<option value="file2">github.com/alxrusinov/shorturl/internal/config/use_config_file.go (12.0%)</option>
				
				<option value="file3">github.com/alxrusinov/shorturl/internal/customerrors/duplicate_value_error.go (100.0%)</option>
				
				<option value="file4">github.com/alxrusinov/shorturl/internal/generator/generator.go (88.2%)</option>
				
				<option value="file5">github.com/alxrusinov/shorturl/internal/generator/mockgenerator/mock_generator.go (100.0%)</option>
				
				<option value="file6">github.com/alxrusinov/shorturl/internal/grpcserver/api_delete_links.go (100.0%)</option>
				
				<option value="file7">github.com/alxrusinov/shorturl/internal/grpcserver/get_original_link.go (100.0%)</option>
				
				<option value="file8">github.com/alxrusinov/shorturl/internal/grpcserver/get_short_link.go (100.0%)</option>
				
				<option value="file9">github.com/alxrusinov/shorturl/internal/grpcserver/get_user_links.go (100.0%)</option>
				
				<option value="file10">github.com/alxrusinov/shorturl/internal/grpcserver/grpc_server.go (25.0%)</option>
				
				<option value="file11">github.com/alxrusinov/shorturl/internal/grpcserver/ping.go (100.0%)</option>
				
				<option value="file12">github.com/alxrusinov/shorturl/internal/grpcserver/shorten.go (100.0%)</option>
				
				<option value="file13">github.com/alxrusinov/shorturl/internal/grpcserver/shorten_batch.go (100.0%)</option>
				
				<option value="file14">github.com/alxrusinov/shorturl/internal/grpcserver/stats.go (100.0%)</option>
				
				<option value="file15">github.com/alxrusinov/shorturl/internal/handler/api_delete_links.go (89.5%)</option>
				
				<option value="file16">github.com/alxrusinov/shorturl/internal/handler/api_shorten.go (90.2%)</option>
				
				<option value="file17">github.com/alxrusinov/shorturl/internal/handler/api_shorten_batch.go (87.9%)</option>
				
				<option value="file18">github.com/alxrusinov/shorturl/internal/handler/get_original_link.go (100.0%)</option>
				
				<option value="file19">github.com/alxrusinov/shorturl/internal/handler/get_short_link.go (93.8%)</option>
				
				<option value="file20">github.com/alxrusinov/shorturl/internal/handler/get_user_links.go (84.6%)</option>
				
				<option value="file21">github.com/alxrusinov/shorturl/internal/handler/handler.go (100.0%)</option>
				
				<option value="file22">github.com/alxrusinov/shorturl/internal/handler/helpers.go (100.0%)</option>
				
				<option value="file23">github.com/alxrusinov/shorturl/internal/handler/middleware.go (85.3%)</option>
				
				<option value="file24">github.com/alxrusinov/shorturl/internal/handler/ping.go (100.0%)</option>
				
				<option value="file25">github.com/alxrusinov/shorturl/internal/handler/stats.go (100.0%)</option>
				
				<option value="file26">github.com/alxrusinov/shorturl/internal/logger/logger.go (100.0%)</option>
				
				<option value="file27">github.com/alxrusinov/shorturl/internal/netutils/netutils.go (100.0%)</option>
				
				<option value="file28">github.com/alxrusinov/shorturl/internal/server/server.go (71.4%)</option>
				
				<option value="file29">github.com/alxrusinov/shorturl/internal/store/dbstore/create_table.go (100.0%)</option>
				
				<option value="file30">github.com/alxrusinov/shorturl/internal/store/dbstore/db_store.go (0.0%)</option>
				
				<option value="file31">github.com/alxrusinov/shorturl/internal/store/dbstore/db_store.mock.go (80.0%)</option>
				
				<option value="file32">github.com/alxrusinov/shorturl/internal/store/dbstore/delete_links.go (94.7%)</option>
				
				<option value="file33">github.com/alxrusinov/shorturl/internal/store/dbstore/get_link.go (100.0%)</option>
				
				<option value="file34">github.com/alxrusinov/shorturl/internal/store/dbstore/get_links.go (92.3%)</option>
				
				<option value="file35">github.com/alxrusinov/shorturl/internal/store/dbstore/get_stat.go (100.0%)</option>
				
				<option value="file36">github.com/alxrusinov/shorturl/internal/store/dbstore/ping.go (100.0%)</option>
				
				<option value="file37">github.com/alxrusinov/shorturl/internal/store/dbstore/set_batch_links.go (100.0%)</option>
				
				<option value="file38">github.com/alxrusinov/shorturl/internal/store/dbstore/set_link.go (100.0%)</option>
				
				<option value="file39">github.com/alxrusinov/shorturl/internal/store/filestore/file_store.go (36.3%)</option>
				
				<option value="file40">github.com/alxrusinov/shorturl/internal/store/inmemorystore/in_memory_store.go (92.6%)</option>
				
				<option value="file41">github.com/alxrusinov/shorturl/internal/store/mockstore/mock_store.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "context"
        "errors"
        "log"
        "net/http"

        "github.com/alxrusinov/shorturl/internal/config"
        "github.com/alxrusinov/shorturl/internal/generator"
        "github.com/alxrusinov/shorturl/internal/grpcserver"
        "github.com/alxrusinov/shorturl/internal/handler"
        "github.com/alxrusinov/shorturl/internal/logger"
        "github.com/alxrusinov/shorturl/internal/model"
        "github.com/alxrusinov/shorturl/internal/server"
        "github.com/alxrusinov/shorturl/internal/store/dbstore"
        "github.com/alxrusinov/shorturl/internal/store/filestore"
        "github.com/alxrusinov/shorturl/internal/store/inmemorystore"
)

// Run configurate and run application
func Run(ctx context.Context, config *config.Config) <span class="cov0" title="0">{
        var sStore handler.Store

        switch </span>{
        case config.DBPath != "":<span class="cov0" title="0">
                sStore = dbstore.NewDBStore(config.DBPath)</span>
        case config.FileStoragePath != "":<span class="cov0" title="0">
                sStore = filestore.NewFileStore(config.FileStoragePath)</span>
        default:<span class="cov0" title="0">
                sStore = inmemorystore.NewInMemoryStore()</span>

        }

        <span class="cov0" title="0">generator := generator.NewGenerator()

        handler := handler.NewHandler(sStore, config.BaseURL, generator, config.TrustedSubnet)
        logger := logger.NewLogger()
        newServer := server.NewServer(handler, config, logger)
        newGRPSServer := grpcserver.NewGRPCServer(sStore, config.GRPCAddress, generator, config.GRPCAddress, config.TrustedSubnet)

        go func() </span><span class="cov0" title="0">{
                var batch [][]model.StoreRecord

                for val := range handler.DeleteChan </span><span class="cov0" title="0">{
                        batch = append(batch, val)
                        sStore.DeleteLinks(batch)

                        batch = batch[0:0]
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                var batch [][]model.StoreRecord

                for val := range handler.DeleteChan </span><span class="cov0" title="0">{
                        batch = append(batch, val)
                        sStore.DeleteLinks(batch)

                        batch = batch[0:0]
                }</span>
        }()

        <span class="cov0" title="0">go func(ctx context.Context) </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                if err := newServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("server has been crashed shutdown")
                }</span>
        }(ctx)

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                var batch [][]model.StoreRecord

                delChan := newGRPSServer.GetDelChan()

                for val := range delChan </span><span class="cov0" title="0">{
                        batch = append(batch, val)
                        sStore.DeleteLinks(batch)

                        batch = batch[0:0]
                }</span>
        }()

        <span class="cov0" title="0">if err := newServer.Run(); !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                log.Fatal("server has been crashed run")
        }</span>

        <span class="cov0" title="0">if err := grpcserver.Run(newGRPSServer); err != nil </span><span class="cov0" title="0">{
                log.Fatal("grpc server has been crashed run")
        }</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "flag"
        "os"
        "sync"
)

// Default fields for config
const (
        // DeafaultBaseURL - base url when server will be started
        DefaulServerAddress = "localhost:8080"
        // DeafaultResponseURL - base url of returning link
        DefaultBaseURL = "http://localhost:8080"
        // DefaultFilePath - path for storage file
        DefaultFilePath = "./config.json"
)

// Config has information about configuration of app
type Config struct {
        ServerAddress   string `json:"server_address"`
        BaseURL         string `json:"base_url"`
        FileStoragePath string `json:"file_storage_path"`
        DBPath          string `json:"database_dsn"`
        TLS             bool   `json:"enable_https"`
        TrustedSubnet   string `json:"trusted_subnet"`
        GRPCAddress     string `json:"grpc_address"`
        ConfigPath      string
}

var once sync.Once

// Init parses flags and initial config
func (config *Config) Init() <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                flag.StringVar(&amp;config.ServerAddress, "a", DefaulServerAddress, "base url when server will be started")
                flag.StringVar(&amp;config.BaseURL, "b", DefaultBaseURL, "base url of returning link")
                flag.StringVar(&amp;config.FileStoragePath, "f", DefaultFilePath, "path for storage file")
                flag.StringVar(&amp;config.DBPath, "d", "", "path to data base")
                flag.BoolVar(&amp;config.TLS, "s", false, "configure http or https server")
                flag.StringVar(&amp;config.ConfigPath, "c", "", "path to config file")
                flag.StringVar(&amp;config.ConfigPath, "config", "", "path to config file")
                flag.StringVar(&amp;config.TrustedSubnet, "t", "", "trust subnet")
                flag.StringVar(&amp;config.GRPCAddress, "g", "", "grpc server address")
        }</span>)

        <span class="cov8" title="1">flag.Parse()

        if baseURL, ok := os.LookupEnv("SERVER_ADDRESS"); ok </span><span class="cov8" title="1">{
                config.ServerAddress = baseURL
        }</span>

        <span class="cov8" title="1">if baseURL, ok := os.LookupEnv("BASE_URL"); ok </span><span class="cov8" title="1">{
                config.BaseURL = baseURL
        }</span>

        <span class="cov8" title="1">if filePath, ok := os.LookupEnv("FILE_STORAGE_PATH"); ok </span><span class="cov8" title="1">{
                config.FileStoragePath = filePath
        }</span>

        <span class="cov8" title="1">if dBPath, ok := os.LookupEnv("DATABASE_DSN"); ok </span><span class="cov8" title="1">{
                config.DBPath = dBPath
        }</span>
        <span class="cov8" title="1">if GRPCAddress, ok := os.LookupEnv("GRPC_ADDRESS"); ok </span><span class="cov0" title="0">{
                config.GRPCAddress = GRPCAddress
        }</span>
        <span class="cov8" title="1">if trustedSubnet, ok := os.LookupEnv("TRUSTED_SUBNET"); ok </span><span class="cov0" title="0">{
                config.TrustedSubnet = trustedSubnet
        }</span>
        <span class="cov8" title="1">if TLS, ok := os.LookupEnv("ENABLE_HTTPS"); ok &amp;&amp; TLS != "" </span><span class="cov0" title="0">{
                config.TLS = true
        }</span>
        <span class="cov8" title="1">if configPath, ok := os.LookupEnv("CONFIG"); ok </span><span class="cov0" title="0">{
                config.ConfigPath = configPath
        }</span>

        <span class="cov8" title="1">useConfigFile(config)</span>
}

// NewConfig return Config instance
func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{}
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "encoding/json"
        "io"
        "os"
)

func readConfig(file *os.File) (*Config, error) <span class="cov0" title="0">{
        content, err := io.ReadAll(file)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">configFromFile := new(Config)

        err = json.Unmarshal(content, &amp;configFromFile)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return configFromFile, nil</span>
}

func useConfigFile(config *Config) <span class="cov8" title="1">{
        file, err := os.Open(config.ConfigPath)

        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">defer file.Close()

        configFromFile, err := readConfig(file)

        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if configFromFile.ServerAddress != "" &amp;&amp; config.ServerAddress == DefaulServerAddress </span><span class="cov0" title="0">{
                config.ServerAddress = configFromFile.ServerAddress
        }</span>

        <span class="cov0" title="0">if configFromFile.BaseURL != "" &amp;&amp; config.BaseURL == DefaultBaseURL </span><span class="cov0" title="0">{
                config.BaseURL = configFromFile.BaseURL
        }</span>

        <span class="cov0" title="0">if configFromFile.FileStoragePath != "" &amp;&amp; config.FileStoragePath == DefaultFilePath </span><span class="cov0" title="0">{
                config.FileStoragePath = configFromFile.FileStoragePath
        }</span>

        <span class="cov0" title="0">if configFromFile.DBPath != "" &amp;&amp; config.DBPath == "" </span><span class="cov0" title="0">{
                config.DBPath = configFromFile.DBPath
        }</span>

        <span class="cov0" title="0">if configFromFile.TLS &amp;&amp; !config.TLS </span><span class="cov0" title="0">{
                config.TLS = configFromFile.TLS
        }</span>

}
</pre>
		
		<pre class="file" id="file3" style="display: none">package customerrors

// DuplicateValueError is error, returns when value exists
type DuplicateValueError struct {
        Err error
}

// Unwrap method of Error interface
func (err *DuplicateValueError) Unwrap() error <span class="cov8" title="1">{
        return err.Err
}</span>

// Error method of Error interface
func (err *DuplicateValueError) Error() string <span class="cov8" title="1">{
        return err.Err.Error()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package generator

import (
        "crypto/md5"
        "crypto/rand"
        "encoding/base64"
)

// Generator has methods for creating random strings
type Generator struct{}

// GenerateRandomString generate random string
func (g *Generator) GenerateRandomString() (string, error) <span class="cov8" title="1">{
        data := make([]byte, 512)

        _, err := rand.Read(data)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">h := md5.New()

        h.Write(data)

        hash := base64.URLEncoding.EncodeToString(h.Sum(nil))

        return hash, nil</span>
}

// GenerateUserID return uaer ID as string
func (g *Generator) GenerateUserID() (string, error) <span class="cov8" title="1">{
        data := make([]byte, 512)

        _, err := rand.Read(data)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">h := md5.New()

        h.Write(data)

        hash := base64.URLEncoding.EncodeToString(h.Sum(nil))

        return hash, nil</span>
}

// NewGenerator generate generator
func NewGenerator() *Generator <span class="cov8" title="1">{
        return &amp;Generator{}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package mockgenerator

import "github.com/stretchr/testify/mock"

const (
        indexZero = iota
        indexOne
)

// MochGenerator - mocked generator
type MockGenerator struct {
        mock.Mock
}

// GenerateRandomString - mocked method of generator
func (mg *MockGenerator) GenerateRandomString() (string, error) <span class="cov8" title="1">{

        args := mg.Called()

        return args.String(indexZero), args.Error(indexOne)
}</span>

// GenerateUserID - mocked method of generator
func (mg *MockGenerator) GenerateUserID() (string, error) <span class="cov8" title="1">{
        args := mg.Called()

        return args.String(indexZero), args.Error(indexOne)
}</span>

// NewMockGenerator return mocked generator
func NewMockGenerator() *MockGenerator <span class="cov8" title="1">{
        return &amp;MockGenerator{}
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package grpcserver

import (
        "context"

        "github.com/alxrusinov/shorturl/internal/model"
        pb "github.com/alxrusinov/shorturl/pkg/grpchandler/proto"
)

// APIDeleteLinks - deletes links for user
func (g *GRPCServer) APIDeleteLinks(ctx context.Context, in *pb.DeleteLinkRequest) (*pb.DeleteResponse, error) <span class="cov8" title="1">{
        var batch []model.StoreRecord

        for _, val := range in.Links </span><span class="cov8" title="1">{
                batch = append(batch, model.StoreRecord{
                        UUID:      in.UserId,
                        ShortLink: val,
                })
        }</span>

        <span class="cov8" title="1">g.deleteChan &lt;- batch

        return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package grpcserver

import (
        "context"

        "github.com/alxrusinov/shorturl/internal/model"
        pb "github.com/alxrusinov/shorturl/pkg/grpchandler/proto"
)

func (g *GRPCServer) GetOriginaltLink(ctx context.Context, in *pb.GetOriginalRequest) (*pb.GetOriginalResponse, error) <span class="cov8" title="1">{

        link := &amp;model.StoreRecord{
                ShortLink: in.ShortenLink,
        }

        res, err := g.store.GetLink(link)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;pb.GetOriginalResponse{
                Link: res.OriginalLink,
        }

        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package grpcserver

import (
        "context"

        pb "github.com/alxrusinov/shorturl/pkg/grpchandler/proto"
)

func (g *GRPCServer) GetShortenLink(ctx context.Context, in *pb.GetShortLinkRequest) (*pb.GetShortLinkResponse, error) <span class="cov8" title="1">{
        shortenURL, err := g.Generator.GenerateRandomString()

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;pb.GetShortLinkResponse{
                ShortenLink: shortenURL,
        }

        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package grpcserver

import (
        "context"
        "fmt"

        pb "github.com/alxrusinov/shorturl/pkg/grpchandler/proto"
)

func (g *GRPCServer) GetUserLinks(ctx context.Context, in *pb.UserLinksRequest) (*pb.UserLinksResponse, error) <span class="cov8" title="1">{
        links, err := g.store.GetLinks(in.UserId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := pb.UserLinksResponse{}

        for _, link := range links </span><span class="cov8" title="1">{
                newLink := &amp;pb.UserLinkResponse{
                        ShortUrl:    fmt.Sprintf("%s/%s", g.responseAddr, link.ShortLink),
                        OriginalUrl: link.OriginalLink,
                }
                result.Objects = append(result.Objects, newLink)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package grpcserver

import (
        "net"

        "github.com/alxrusinov/shorturl/internal/model"
        pb "github.com/alxrusinov/shorturl/pkg/grpchandler/proto"
        "google.golang.org/grpc"
        _ "google.golang.org/grpc/encoding/gzip"
)

// Store - store for grpc
type Store interface {
        GetLink(arg *model.StoreRecord) (*model.StoreRecord, error)
        SetLink(arg *model.StoreRecord) (*model.StoreRecord, error)
        SetBatchLink(arg []*model.StoreRecord) ([]*model.StoreRecord, error)
        Ping() error
        GetLinks(userID string) ([]model.StoreRecord, error)
        DeleteLinks(shorts [][]model.StoreRecord) error
        GetStat() (*model.StatResponse, error)
}

// Type Generator is a type for generator
type Generator interface {
        GenerateRandomString() (string, error)
        GenerateUserID() (string, error)
}

// GRPCServer - typ of grpc server
type GRPCServer struct {
        pb.UnimplementedHandlerServer
        store         Store
        addr          string
        responseAddr  string
        trustedSubnet string
        deleteChan    chan []model.StoreRecord
        Generator     Generator
}

// Run - method of GRPCServer for runnning app
func Run(g *GRPCServer) error <span class="cov0" title="0">{
        server, err := net.Listen("tcp", g.addr)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s := grpc.NewServer()

        pb.RegisterHandlerServer(s, g)

        err = s.Serve(server)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func (g *GRPCServer) GetDelChan() &lt;-chan []model.StoreRecord <span class="cov8" title="1">{
        return g.deleteChan
}</span>

// NewGRPCServer creates GRPCServer
func NewGRPCServer(store Store, addr string, generator Generator, responseAddr string, trustedSubnet string) *GRPCServer <span class="cov8" title="1">{
        server := &amp;GRPCServer{
                store:         store,
                addr:          addr,
                deleteChan:    make(chan []model.StoreRecord),
                Generator:     generator,
                responseAddr:  responseAddr,
                trustedSubnet: trustedSubnet,
        }

        return server
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package grpcserver

import (
        "context"

        pb "github.com/alxrusinov/shorturl/pkg/grpchandler/proto"
)

func (g *GRPCServer) Ping(ctx context.Context, req *pb.PingRequest) (*pb.PingResponse, error) <span class="cov8" title="1">{
        var response pb.PingResponse

        err := g.store.Ping()

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package grpcserver

import (
        "context"
        "fmt"

        "github.com/alxrusinov/shorturl/internal/model"
        pb "github.com/alxrusinov/shorturl/pkg/grpchandler/proto"
)

func (g *GRPCServer) Shorten(ctx context.Context, in *pb.ShortenRequest) (*pb.ShortenResponse, error) <span class="cov8" title="1">{
        shortenURL, err := g.Generator.GenerateRandomString()

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">links := &amp;model.StoreRecord{
                ShortLink:    shortenURL,
                OriginalLink: in.Url,
                UUID:         in.UserId,
        }

        res, err := g.store.SetLink(links)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;pb.ShortenResponse{
                Result: fmt.Sprintf("%s/%s", g.responseAddr, res.ShortLink),
        }

        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package grpcserver

import (
        "context"
        "fmt"

        "github.com/alxrusinov/shorturl/internal/model"
        pb "github.com/alxrusinov/shorturl/pkg/grpchandler/proto"
)

func (g *GRPCServer) ShortenBatch(ctx context.Context, in *pb.ShortenBatchRequest) (*pb.ShortenBatchResponse, error) <span class="cov8" title="1">{
        var content []*model.StoreRecord

        for _, val := range in.Objects </span><span class="cov8" title="1">{

                shortenURL, err := g.Generator.GenerateRandomString()

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">rec := &amp;model.StoreRecord{
                        UUID:          in.UserId,
                        OriginalLink:  val.OriginalUrl,
                        CorrelationID: val.CorrelationId,
                        ShortLink:     shortenURL,
                }

                content = append(content, rec)</span>
        }

        <span class="cov8" title="1">res, err := g.store.SetBatchLink(content)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := new(pb.ShortenBatchResponse)

        for _, val := range res </span><span class="cov8" title="1">{
                rec := &amp;pb.ShortenItemResponse{
                        CorrelationId: val.CorrelationID,
                        ShortUrl:      fmt.Sprintf("%s/%s", g.responseAddr, val.ShortLink),
                }

                result.Objects = append(result.Objects, rec)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package grpcserver

import (
        "context"
        "errors"
        "fmt"

        "github.com/alxrusinov/shorturl/internal/netutils"
        pb "github.com/alxrusinov/shorturl/pkg/grpchandler/proto"
)

func (g *GRPCServer) Stats(ctx context.Context, in *pb.StatsRequest) (*pb.StatsResponse, error) <span class="cov8" title="1">{
        if in.XRealIp == "" </span><span class="cov8" title="1">{
                return nil, errors.New("forbidden")
        }</span>

        <span class="cov8" title="1">trusted, err := netutils.CheckSubnet(g.trustedSubnet, in.XRealIp)

        if !trusted || err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("forbidden: %v", err)
        }</span>

        <span class="cov8" title="1">res, err := g.store.GetStat()

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;pb.StatsResponse{
                Urls:  int32(res.URLS),
                Users: int32(res.Users),
        }

        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "io"
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/alxrusinov/shorturl/internal/model"
)

// APIDeleteLinks - route for deleting links
// /api/user/urls
func (handler *Handler) APIDeleteLinks(ctx *gin.Context) <span class="cov8" title="1">{
        var userID string

        val, ok := ctx.Get("userID")

        if !ok </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">userID, ok = val.(string)

        if !ok </span><span class="cov0" title="0">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">var shorts []string

        if err := json.NewDecoder(ctx.Request.Body).Decode(&amp;shorts); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">defer ctx.Request.Body.Close()

        var batch []model.StoreRecord

        for _, val := range shorts </span><span class="cov8" title="1">{
                batch = append(batch, model.StoreRecord{
                        UUID:      userID,
                        ShortLink: val,
                })
        }</span>

        <span class="cov8" title="1">handler.DeleteChan &lt;- batch

        ctx.Status(http.StatusAccepted)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "io"
        "net/http"

        "github.com/buger/jsonparser"
        "github.com/gin-gonic/gin"

        "github.com/alxrusinov/shorturl/internal/customerrors"
        "github.com/alxrusinov/shorturl/internal/model"
)

// APIShorten - route adds url
// /api/shorten
func (handler *Handler) APIShorten(ctx *gin.Context) <span class="cov8" title="1">{
        var userID string

        val, ok := ctx.Get("userID")

        if !ok </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">userID, ok = val.(string)

        if !ok </span><span class="cov0" title="0">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">result := new(APIShortenResult)

        body, err := io.ReadAll(ctx.Request.Body)

        defer ctx.Request.Body.Close()

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">originalLink, err := jsonparser.GetString(body, "url")

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">shortenURL, err := handler.Generator.GenerateRandomString()

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">links := &amp;model.StoreRecord{
                ShortLink:    shortenURL,
                OriginalLink: originalLink,
                UUID:         userID,
        }

        res, err := handler.store.SetLink(links)

        dbErr := &amp;customerrors.DuplicateValueError{}

        if err != nil </span><span class="cov8" title="1">{
                if !errors.As(err, &amp;dbErr) </span><span class="cov8" title="1">{
                        ctx.AbortWithStatus(http.StatusInternalServerError)
                        return

                }</span>

                <span class="cov8" title="1">dbErr.Err = err</span>
        }

        <span class="cov8" title="1">links.ShortLink = res.ShortLink

        result.Result = createShortLink(handler.options.responseAddr, links.ShortLink)

        resp, err := json.Marshal(&amp;result)

        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if dbErr.Err != nil </span><span class="cov8" title="1">{
                ctx.Data(http.StatusConflict, "application/json", resp)
                return
        }</span>

        <span class="cov8" title="1">ctx.Data(http.StatusCreated, "application/json", resp)</span>

}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "io"
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/alxrusinov/shorturl/internal/model"
)

// APIShortenBatch - route adds urls by batch
// /api/shorten/batch
func (handler *Handler) APIShortenBatch(ctx *gin.Context) <span class="cov8" title="1">{
        var userID string

        val, ok := ctx.Get("userID")

        if !ok </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">userID, ok = val.(string)

        if !ok </span><span class="cov0" title="0">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">var content []*model.StoreRecord

        if err := json.NewDecoder(ctx.Request.Body).Decode(&amp;content); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">defer ctx.Request.Body.Close()

        for _, val := range content </span><span class="cov8" title="1">{
                shortenURL, err := handler.Generator.GenerateRandomString()

                if err != nil </span><span class="cov8" title="1">{
                        ctx.AbortWithStatus(http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">val.ShortLink = shortenURL
                val.UUID = userID</span>
        }

        <span class="cov8" title="1">result, err := handler.store.SetBatchLink(content)

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">for _, val := range result </span><span class="cov8" title="1">{
                val.ShortLink = createShortLink(handler.options.responseAddr, val.ShortLink)
                val.OriginalLink = ""
        }</span>

        <span class="cov8" title="1">resp, err := json.Marshal(&amp;result)

        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">ctx.Data(http.StatusCreated, "application/json", resp)</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handler

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/alxrusinov/shorturl/internal/model"
)

// GetOriginalLink - route return original link
// /:id
func (handler *Handler) GetOriginalLink(ctx *gin.Context) <span class="cov8" title="1">{
        id := ctx.Param("id")
        defer ctx.Request.Body.Close()

        links := &amp;model.StoreRecord{
                ShortLink: id,
        }

        res, err := handler.store.GetLink(links)

        if err != nil </span><span class="cov8" title="1">{
                ctx.Status(http.StatusGone)
                return
        }</span>

        <span class="cov8" title="1">ctx.Header("Location", res.OriginalLink)
        ctx.Status(http.StatusTemporaryRedirect)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handler

import (
        "errors"
        "io"
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/alxrusinov/shorturl/internal/customerrors"
        "github.com/alxrusinov/shorturl/internal/model"
)

// GetShortLink - route adds url
// /
func (handler *Handler) GetShortLink(ctx *gin.Context) <span class="cov8" title="1">{
        var userID string

        val, ok := ctx.Get("userID")

        if !ok </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">userID, ok = val.(string)

        if !ok </span><span class="cov0" title="0">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(ctx.Request.Body)

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">originURL := string(body)

        shortenURL, err := handler.Generator.GenerateRandomString()

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">links := &amp;model.StoreRecord{
                ShortLink:    shortenURL,
                OriginalLink: originURL,
                UUID:         userID,
        }

        res, err := handler.store.SetLink(links)

        dbErr := &amp;customerrors.DuplicateValueError{}

        if err != nil </span><span class="cov8" title="1">{
                if !errors.As(err, &amp;dbErr) </span><span class="cov8" title="1">{
                        ctx.AbortWithStatus(http.StatusInternalServerError)
                        return

                }</span>
        }

        <span class="cov8" title="1">links.ShortLink = res.ShortLink

        defer ctx.Request.Body.Close()

        resp := []byte(createShortLink(handler.options.responseAddr, links.ShortLink))

        if dbErr.Err != nil </span><span class="cov8" title="1">{
                ctx.Data(http.StatusConflict, "text/plain", resp)
                return
        }</span>

        <span class="cov8" title="1">ctx.Data(http.StatusCreated, "text/plain", resp)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handler

import (
        "encoding/json"
        "net/http"

        "github.com/gin-gonic/gin"
)

// GetUserLinks - route reteurn all users urls
// /api/user/urls
func (handler *Handler) GetUserLinks(ctx *gin.Context) <span class="cov8" title="1">{
        var userID string

        val, ok := ctx.Get("userID")

        if !ok </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">userID, ok = val.(string)

        if !ok </span><span class="cov0" title="0">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">links, err := handler.store.GetLinks(userID)

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if len(links) == 0 </span><span class="cov8" title="1">{
                ctx.Header("Content-Type", "application/json")
                ctx.Status(http.StatusNoContent)
                return
        }</span>

        <span class="cov8" title="1">var result []struct {
                Short    string `json:"short_url"`
                Original string `json:"original_url"`
        }

        for _, link := range links </span><span class="cov8" title="1">{
                newLink := struct {
                        Short    string `json:"short_url"`
                        Original string `json:"original_url"`
                }{
                        Short:    createShortLink(handler.options.responseAddr, link.ShortLink),
                        Original: link.OriginalLink,
                }
                result = append(result, newLink)
        }</span>

        <span class="cov8" title="1">resp, err := json.Marshal(&amp;result)

        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">ctx.Data(http.StatusOK, "application/json", resp)</span>

}
</pre>
		
		<pre class="file" id="file21" style="display: none">package handler

import (
        "github.com/alxrusinov/shorturl/internal/model"
)

type options struct {
        responseAddr  string
        trustedSubnet string
}

// Handler - structure with information about handler entity
type Handler struct {
        store       Store
        options     *options
        Middlewares *Middlewares
        DeleteChan  chan []model.StoreRecord
        Generator   Generator
}

// Type of result, returning by apishorten handler
type APIShortenResult struct {
        Result string `json:"result"`
}

// Type of body for api shorten handler
type APIShortenBody struct {
        URL string `json:"url"`
}

// Store - interface of store
type Store interface {
        GetLink(arg *model.StoreRecord) (*model.StoreRecord, error)
        SetLink(arg *model.StoreRecord) (*model.StoreRecord, error)
        SetBatchLink(arg []*model.StoreRecord) ([]*model.StoreRecord, error)
        Ping() error
        GetLinks(userID string) ([]model.StoreRecord, error)
        DeleteLinks(shorts [][]model.StoreRecord) error
        GetStat() (*model.StatResponse, error)
}

// Type Generator is a type for generator
type Generator interface {
        GenerateRandomString() (string, error)
        GenerateUserID() (string, error)
}

// NewHandler returns new handler instance
func NewHandler(sStore Store, responseAddr string, generator Generator, trustedSubnet string) *Handler <span class="cov8" title="1">{
        handler := &amp;Handler{
                store: sStore,
                options: &amp;options{
                        responseAddr:  responseAddr,
                        trustedSubnet: trustedSubnet,
                },
                DeleteChan:  make(chan []model.StoreRecord),
                Generator:   generator,
                Middlewares: NewMiddlwares(generator),
        }

        return handler
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package handler

import (
        "errors"
        "fmt"
)

type errReader struct{}

// Read implements method Read for reader
func (er *errReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return 0, errors.New("test error")
}</span>

func createShortLink(host string, shorten string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", host, shorten)
}</span>

func newErrReader() *errReader <span class="cov8" title="1">{
        return &amp;errReader{}
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package handler

import (
        "compress/gzip"
        "io"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog"
)

const (
        seconds = 60
        minutes = 60
        hours   = 24
)

// Middlewares - middlewares entity
type Middlewares struct {
        Generator Generator
}

// UserCookie - const of name cookie for user id
const UserCookie = "user_cookie"

func checkContentType(values []string) bool <span class="cov8" title="1">{
        var zippingContentType = map[string]struct{}{"text/html": {}, "application/json": {}}

        for _, value := range values </span><span class="cov8" title="1">{
                if _, ok := zippingContentType[value]; ok </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func checkGzip(values []string) bool <span class="cov8" title="1">{
        const zipFormat = "gzip"

        for _, value := range values </span><span class="cov8" title="1">{
                if value == zipFormat </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Middleware - type of middleware reurning gin handler function
type Middleware func() gin.HandlerFunc

type gzipWriter struct {
        gin.ResponseWriter
        writer *gzip.Writer
}

// Write implements interface of gin writer
func (g *gzipWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        g.Header().Del("Content-Length")
        return g.writer.Write(data)
}</span>

// WriteHeader implements interface of gin writing header
func (g *gzipWriter) WriteHeader(code int) <span class="cov0" title="0">{
        g.Header().Del("Content-Length")
        g.ResponseWriter.WriteHeader(code)
}</span>

// LoggerMiddleware - middleware adds logger
func (middlwares *Middlewares) LoggerMiddleware(logger zerolog.Logger) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()

                uri := c.Request.RequestURI
                method := c.Request.Method

                c.Next()

                size := c.Writer.Size()
                status := c.Writer.Status()

                duration := time.Since(start)

                logger.Info().Str("uri", uri).Str("method", method).Int("status", status).Dur("duration", duration).Int("size", size)

        }</span>
}

// CompressMiddleware - middleware adds compressing of contetnt
func (middlwares *Middlewares) CompressMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                contentEncoding := c.Request.Header.Values("Content-Encoding")

                contentType := c.Request.Header.Values("Content-Type")

                if !checkContentType(contentType) &amp;&amp; c.Request.Method != http.MethodPost </span><span class="cov8" title="1">{
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">if checkGzip(contentEncoding) </span><span class="cov8" title="1">{
                        rawContent, err := gzip.NewReader(c.Request.Body)

                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov8" title="1">{
                                c.AbortWithStatus(http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov0" title="0">defer rawContent.Close()

                        c.Request.Body = rawContent
                        c.Request.Header.Set("Content-Encoding", "identity")</span>

                }

                <span class="cov8" title="1">c.Next()

                acceptEncoding := c.Writer.Header().Values("Accept-Encoding")

                if checkGzip(acceptEncoding) </span><span class="cov8" title="1">{
                        gz := gzip.NewWriter(c.Writer)
                        c.Writer.Header().Set("Content-Encoding", "gzip")
                        c.Writer = &amp;gzipWriter{c.Writer, gz}
                }</span>

        }
}

// CookieMiddleware - middleware adds cookie
func (middlwares *Middlewares) CookieMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                fullPath := c.FullPath()
                method := c.Request.Method

                if method == http.MethodPost </span><span class="cov8" title="1">{
                        userID, err := c.Cookie(UserCookie)

                        if err != nil </span><span class="cov8" title="1">{
                                userID, err = middlwares.Generator.GenerateUserID()

                                if err != nil </span><span class="cov8" title="1">{
                                        c.AbortWithStatus(http.StatusInternalServerError)
                                        return
                                }</span>

                                <span class="cov8" title="1">c.SetCookie(UserCookie, userID, seconds*minutes*hours, "/", "localhost", false, true)</span>

                        }

                        <span class="cov8" title="1">c.Set("userID", userID)

                        c.Next()

                        return</span>
                }

                <span class="cov8" title="1">if method == http.MethodGet </span><span class="cov8" title="1">{
                        if fullPath == "/api/user/urls" </span><span class="cov8" title="1">{
                                userID, err := c.Cookie(UserCookie)

                                if err != nil </span><span class="cov0" title="0">{
                                        c.AbortWithStatus(http.StatusUnauthorized)
                                        return
                                }</span>

                                <span class="cov8" title="1">c.Set("userID", userID)</span>
                        }

                        <span class="cov8" title="1">c.Next()

                        return</span>
                }

                <span class="cov8" title="1">if method == http.MethodDelete </span><span class="cov8" title="1">{
                        userID, err := c.Cookie(UserCookie)

                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">c.Set("userID", userID)

                        c.Next()

                        return</span>
                }

        }
}

// NewMiddlwares create new Middlwares
func NewMiddlwares(generator Generator) *Middlewares <span class="cov8" title="1">{
        return &amp;Middlewares{
                Generator: generator,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package handler

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

// Ping - handler for pinging store
func (handler *Handler) Ping(ctx *gin.Context) <span class="cov8" title="1">{
        err := handler.store.Ping()

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">ctx.Status(http.StatusOK)</span>

}
</pre>
		
		<pre class="file" id="file25" style="display: none">package handler

import (
        "net/http"

        "github.com/alxrusinov/shorturl/internal/netutils"
        "github.com/gin-gonic/gin"
)

// Stats - handler for statistics of urls and users
func (handler Handler) Stats(ctx *gin.Context) <span class="cov8" title="1">{
        ip := ctx.Request.Header.Get("X-Real-IP")

        trusted, err := netutils.CheckSubnet(handler.options.trustedSubnet, ip)

        if !trusted || err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusForbidden)
                return
        }</span>

        <span class="cov8" title="1">res, err := handler.store.GetStat()

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, res)</span>

}
</pre>
		
		<pre class="file" id="file26" style="display: none">package logger

import (
        "os"

        "github.com/rs/zerolog"
)

// NewLogger creates instance of logger
func NewLogger() zerolog.Logger <span class="cov8" title="1">{
        zerolog.SetGlobalLevel(zerolog.InfoLevel)
        logger := zerolog.New(os.Stdout)

        return logger
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package netutils

import "net"

// CheckSubnet - checks including ip into trustedSubnet
func CheckSubnet(trustedSubnet, ip string) (bool, error) <span class="cov8" title="1">{
        if trustedSubnet == "" </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">_, subnet, err := net.ParseCIDR(trustedSubnet)

        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">ipNet := net.ParseIP(ip)

        trusted := subnet.Contains(ipNet)

        return trusted, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package server

import (
        "context"
        "net/http"

        "github.com/gin-contrib/pprof"
        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog"

        "github.com/alxrusinov/shorturl/internal/config"
        "github.com/alxrusinov/shorturl/internal/handler"
)

// Server has information about server-mux, handler and server run address
type Server struct {
        mux     *gin.Engine
        handler *handler.Handler
        addr    string
        server  *http.Server
        TLS     bool
}

// Run runs the server
func (server *Server) Run() error <span class="cov0" title="0">{
        if server.TLS </span><span class="cov0" title="0">{
                return server.server.ListenAndServe()
        }</span>

        <span class="cov0" title="0">return server.server.ListenAndServe()</span>

}

// Shutsown realize gracefull shutdown server
func (server *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if err := server.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// NewServer initialize and return new server instance
func NewServer(handler *handler.Handler, config *config.Config, logger zerolog.Logger) *Server <span class="cov8" title="1">{
        server := &amp;Server{
                mux:     gin.New(),
                handler: handler,
                addr:    config.ServerAddress,
                TLS:     config.TLS,
        }

        server.mux.Use(server.handler.Middlewares.LoggerMiddleware(logger))

        server.mux.Use(server.handler.Middlewares.CompressMiddleware())

        server.mux.Use(server.handler.Middlewares.CookieMiddleware())

        server.mux.POST("/", server.handler.GetShortLink)

        server.mux.GET("/:id", server.handler.GetOriginalLink)

        server.mux.POST("/api/shorten", server.handler.APIShorten)

        server.mux.GET("/ping", server.handler.Ping)

        server.mux.POST("/api/shorten/batch", server.handler.APIShortenBatch)

        server.mux.GET("/api/user/urls", server.handler.GetUserLinks)

        server.mux.DELETE("/api/user/urls", server.handler.APIDeleteLinks)

        server.mux.GET("/api/internal/stats", server.handler.Stats)
        pprof.Register(server.mux)

        server.server = &amp;http.Server{
                Addr:    server.addr,
                Handler: server.mux,
        }

        return server
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package dbstore

import "context"

func (store *DBStore) createTable() error <span class="cov8" title="1">{
        initialQuery := `CREATE TABLE IF NOT EXISTS links (
                id SERIAL PRIMARY KEY,
                user_id TEXT,
                short TEXT,
                original TEXT UNIQUE,
                correlation_id TEXT,
                is_deleted BOOLEAN NOT NULL DEFAULT FALSE
        );`

        _, err := store.db.ExecContext(context.Background(), initialQuery)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package dbstore

import (
        "database/sql"
        "log"

        _ "github.com/jackc/pgx/v5/stdlib"
)

// DBStore implements Store interface for data base
type DBStore struct {
        db *sql.DB
}

// NewDBStore initializes and returns data base store instance
func NewDBStore(dbPath string) *DBStore <span class="cov0" title="0">{
        store := &amp;DBStore{}

        db, err := sql.Open("pgx", dbPath)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">store.db = db

        err = store.createTable()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return store</span>
}

// CloseConnection is a method closed db connection
func CloseConnection(db *sql.DB) <span class="cov0" title="0">{
        defer db.Close()

}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package dbstore

import (
        "github.com/DATA-DOG/go-sqlmock"
        _ "github.com/jackc/pgx/v5/stdlib"
)

// NewDBStoreMock creates db mock instance
func NewDBStoreMock() (*DBStore, sqlmock.Sqlmock, error) <span class="cov8" title="1">{
        db, mock, err := sqlmock.New(sqlmock.MonitorPingsOption(true))

        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">storeMock := &amp;DBStore{
                db: db,
        }

        return storeMock, mock, nil</span>

}
</pre>
		
		<pre class="file" id="file32" style="display: none">package dbstore

import (
        "context"
        "fmt"
        "strings"

        "github.com/alxrusinov/shorturl/internal/model"
)

// DeleteLinks deletes links from data base
func (store *DBStore) DeleteLinks(shorts [][]model.StoreRecord) error <span class="cov8" title="1">{
        tx, err := store.db.Begin()

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">defer tx.Commit()

        preparedShorts := []string{}
        preparedIDs := []string{}

        for _, val := range shorts </span><span class="cov8" title="1">{
                userID := val[0].UUID
                preparedIDs = append(preparedIDs, fmt.Sprint("'"+userID+"'"))

                for _, shortLink := range val </span><span class="cov8" title="1">{
                        preparedShorts = append(preparedShorts, fmt.Sprint("'"+shortLink.ShortLink+"'"))
                }</span>
        }

        <span class="cov8" title="1">shortsPlaceholders := strings.Join(preparedShorts, ", ")
        userIDsPlaceholders := strings.Join(preparedIDs, ", ")

        rows, err := tx.QueryContext(context.Background(), `UPDATE links SET is_deleted = TRUE WHERE user_id = ANY(ARRAY[`+userIDsPlaceholders+`]) and short = ANY(ARRAY[`+shortsPlaceholders+`]) RETURNING id;`)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}
</pre>
		
		<pre class="file" id="file33" style="display: none">package dbstore

import (
        "context"

        "github.com/alxrusinov/shorturl/internal/model"
)

// GetLink returns original link from data base by shorten
func (store *DBStore) GetLink(arg *model.StoreRecord) (*model.StoreRecord, error) <span class="cov8" title="1">{
        var s string
        err := store.db.QueryRowContext(context.Background(), "SELECT original FROM links WHERE short = $1 and is_deleted = FALSE", arg.ShortLink).Scan(&amp;s)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">arg.OriginalLink = s

        return arg, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package dbstore

import (
        "context"

        "github.com/alxrusinov/shorturl/internal/model"
)

// GetLinks returns information about all users links from data base
func (store *DBStore) GetLinks(userID string) ([]model.StoreRecord, error) <span class="cov8" title="1">{
        rows, err := store.db.QueryContext(context.Background(), "SELECT user_id, short, original, correlation_id, is_deleted FROM links WHERE user_id = $1", userID)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer rows.Close()

        var result []model.StoreRecord

        for rows.Next() </span><span class="cov8" title="1">{
                var row model.StoreRecord

                if err := rows.Scan(&amp;row.UUID, &amp;row.ShortLink, &amp;row.OriginalLink, &amp;row.CorrelationID, &amp;row.Deleted); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">result = append(result, row)</span>

        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>

}
</pre>
		
		<pre class="file" id="file35" style="display: none">package dbstore

import (
        "github.com/alxrusinov/shorturl/internal/model"
)

// GetStat - gets dtatistics of urls and users
func (store *DBStore) GetStat() (*model.StatResponse, error) <span class="cov8" title="1">{
        result := new(model.StatResponse)

        err := store.db.QueryRow("SELECT count(*) AS users, count(DISTINCT user_id) AS links FROM links").Scan(&amp;result.URLS, &amp;result.Users)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package dbstore

// Ping pings data base
func (store *DBStore) Ping() error <span class="cov8" title="1">{
        err := store.db.Ping()

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package dbstore

import (
        "context"
        "errors"
        "io"

        "github.com/alxrusinov/shorturl/internal/model"
)

// SetBatchLink adds links to data base by batch
func (store *DBStore) SetBatchLink(arg []*model.StoreRecord) ([]*model.StoreRecord, error) <span class="cov8" title="1">{
        tx, err := store.db.Begin()

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer tx.Rollback()

        response := make([]*model.StoreRecord, 0)

        for _, val := range arg </span><span class="cov8" title="1">{
                res := &amp;model.StoreRecord{}
                err := store.db.QueryRowContext(context.Background(), insertQuery, val.ShortLink, val.OriginalLink, val.CorrelationID, val.UUID).Scan(&amp;res.ShortLink, &amp;res.OriginalLink, &amp;res.CorrelationID, &amp;res.UUID)

                if err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">response = append(response, res)</span>

        }

        <span class="cov8" title="1">err = tx.Commit()

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return response, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package dbstore

import (
        "context"

        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"

        "github.com/alxrusinov/shorturl/internal/customerrors"
        "github.com/alxrusinov/shorturl/internal/model"
)

// SetLink adds link to data base
func (store *DBStore) SetLink(arg *model.StoreRecord) (*model.StoreRecord, error) <span class="cov8" title="1">{
        var err error
        dbQuery := `INSERT INTO links (short, original, correlation_id, user_id)
                                VALUES ($1, $2, $3, $4);
                                `

        selectQuery := `SELECT short FROM links WHERE original = $1;`

        _, err = store.db.ExecContext(context.Background(), dbQuery, arg.ShortLink, arg.OriginalLink, arg.CorrelationID, arg.UUID)

        if err != nil </span><span class="cov8" title="1">{
                if dbErr, ok := err.(*pgconn.PgError); ok </span><span class="cov8" title="1">{
                        if dbErr.Code == pgerrcode.UniqueViolation </span><span class="cov8" title="1">{

                                err := store.db.QueryRowContext(context.Background(), selectQuery, arg.OriginalLink).Scan(&amp;arg.ShortLink)

                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">return arg, &amp;customerrors.DuplicateValueError{Err: dbErr}</span>
                        }
                }
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">return arg, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package filestore

import (
        "bufio"
        "encoding/json"
        "errors"
        "os"

        "github.com/google/uuid"

        "github.com/alxrusinov/shorturl/internal/customerrors"
        "github.com/alxrusinov/shorturl/internal/model"
)

// FileStore is variant of Store
type FileStore struct {
        filePath string
}

// GetLink returns original link by shorten
func (store *FileStore) GetLink(arg *model.StoreRecord) (*model.StoreRecord, error) <span class="cov8" title="1">{
        file, err := os.OpenFile(store.filePath, os.O_RDONLY, 0666)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov8" title="1">{
                record := &amp;model.StoreRecord{}
                err := json.Unmarshal(scanner.Bytes(), &amp;record)
                if err == nil &amp;&amp; record.ShortLink == arg.ShortLink </span><span class="cov8" title="1">{
                        arg.OriginalLink = record.OriginalLink
                        return arg, nil
                }</span>
        }

        <span class="cov8" title="1">if scanner.Err() != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return nil, errors.New("not found")</span>
}

// SetLink add link to store
func (store *FileStore) SetLink(arg *model.StoreRecord) (*model.StoreRecord, error) <span class="cov8" title="1">{
        file, err := os.OpenFile(store.filePath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov8" title="1">{
                record := &amp;model.StoreRecord{}
                err := json.Unmarshal(scanner.Bytes(), &amp;record)
                if err == nil &amp;&amp; record.OriginalLink == arg.OriginalLink </span><span class="cov8" title="1">{
                        arg.UUID = record.UUID
                        return arg, &amp;customerrors.DuplicateValueError{Err: errors.New("record already exists")}
                }</span>
        }

        <span class="cov8" title="1">if scanner.Err() != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">newUUID := uuid.NewString()

        record := &amp;model.StoreRecord{
                UUID:          newUUID,
                CorrelationID: arg.CorrelationID,
                OriginalLink:  arg.OriginalLink,
                ShortLink:     arg.ShortLink,
        }

        result, err := json.Marshal(record)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = file.Write(append(result, []byte("\n")...))

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = file.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return arg, nil</span>

}

// Ping pings file store
func (store *FileStore) Ping() error <span class="cov8" title="1">{
        file, err := os.OpenFile(store.filePath, os.O_WRONLY|os.O_APPEND, 0666)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return file.Close()</span>
}

// SetBatchLink adds links to file store by batch
func (store *FileStore) SetBatchLink(arg []*model.StoreRecord) ([]*model.StoreRecord, error) <span class="cov0" title="0">{
        file, err := os.OpenFile(store.filePath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">newUUID := uuid.NewString()

        for _, val := range arg </span><span class="cov0" title="0">{

                record := &amp;model.StoreRecord{
                        UUID:          newUUID,
                        CorrelationID: val.CorrelationID,
                        OriginalLink:  val.OriginalLink,
                        ShortLink:     val.ShortLink,
                }

                result, err := json.Marshal(record)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">_, err = file.Write(append(result, []byte("\n")...))

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        }

        <span class="cov0" title="0">err = file.Close()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return arg, nil</span>

}

// GetLinks returns all users links from file store
func (store *FileStore) GetLinks(userID string) ([]model.StoreRecord, error) <span class="cov0" title="0">{
        file, err := os.OpenFile(store.filePath, os.O_RDONLY, 0666)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)

        var result []model.StoreRecord

        for scanner.Scan() </span><span class="cov0" title="0">{
                record := &amp;model.StoreRecord{}
                err := json.Unmarshal(scanner.Bytes(), &amp;record)
                if err == nil &amp;&amp; userID == record.UUID </span><span class="cov0" title="0">{
                        result = append(result, *record)
                }</span>
        }

        <span class="cov0" title="0">if scanner.Err() != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>

}

// DeleteLinks deletes links from store by batch
func (store *FileStore) DeleteLinks(shorts [][]model.StoreRecord) error <span class="cov0" title="0">{
        file, err := os.OpenFile(store.filePath, os.O_WRONLY|os.O_CREATE, 0666)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer file.Close()

        var preparedShorts []model.StoreRecord

        for _, val := range shorts </span><span class="cov0" title="0">{
                preparedShorts = append(preparedShorts, val...)
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(file)

        var result []model.StoreRecord

        for scanner.Scan() </span><span class="cov0" title="0">{
                record := &amp;model.StoreRecord{}
                err := json.Unmarshal(scanner.Bytes(), &amp;record)

                if err == nil </span><span class="cov0" title="0">{
                        for _, rec := range preparedShorts </span><span class="cov0" title="0">{
                                if rec.UUID == record.UUID &amp;&amp; rec.ShortLink == record.ShortLink </span><span class="cov0" title="0">{
                                        record.Deleted = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">result = append(result, *record)</span>
                }
        }

        <span class="cov0" title="0">if scanner.Err() != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">content, err := json.Marshal(&amp;result)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = file.Write(content)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

// GetStat - gets dtatistics of urls and users
func (store *FileStore) GetStat() (*model.StatResponse, error) <span class="cov0" title="0">{
        result := new(model.StatResponse)

        return result, nil
}</span>

// NewFileStore returns new instance of file store
func NewFileStore(filePath string) *FileStore <span class="cov8" title="1">{
        store := &amp;FileStore{filePath: filePath}

        return store
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package inmemorystore

import (
        "errors"

        "github.com/alxrusinov/shorturl/internal/model"
)

// InMemoryStore is inmemory variant of store
type InMemoryStore struct {
        data map[string]*model.StoreRecord
}

// GetLink returns link from store
func (store *InMemoryStore) GetLink(arg *model.StoreRecord) (*model.StoreRecord, error) <span class="cov8" title="1">{
        link, ok := store.data[arg.ShortLink]
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.New("key error")
        }</span>

        <span class="cov8" title="1">arg.OriginalLink = link.OriginalLink

        return arg, nil</span>

}

// SetLink adds link to store
func (store *InMemoryStore) SetLink(arg *model.StoreRecord) (*model.StoreRecord, error) <span class="cov8" title="1">{
        store.data[arg.ShortLink] = arg

        return arg, nil
}</span>

// Ping pings store
func (store *InMemoryStore) Ping() error <span class="cov8" title="1">{
        return nil
}</span>

// SetBatchLink adds links to store by batch
func (store *InMemoryStore) SetBatchLink(arg []*model.StoreRecord) ([]*model.StoreRecord, error) <span class="cov8" title="1">{
        for _, val := range arg </span><span class="cov8" title="1">{
                store.data[val.ShortLink] = val
        }</span>

        <span class="cov8" title="1">return arg, nil</span>
}

// GetLinks returns all users links
func (store *InMemoryStore) GetLinks(userID string) ([]model.StoreRecord, error) <span class="cov8" title="1">{
        var result []model.StoreRecord

        for _, val := range store.data </span><span class="cov8" title="1">{
                if val.UUID == userID </span><span class="cov8" title="1">{
                        result = append(result, *val)

                }</span>

        }

        <span class="cov8" title="1">return result, nil</span>
}

// DeleteLinks deletes links by batch
func (store *InMemoryStore) DeleteLinks(shorts [][]model.StoreRecord) error <span class="cov8" title="1">{
        for _, val := range shorts </span><span class="cov8" title="1">{
                for _, short := range val </span><span class="cov8" title="1">{
                        if record, ok := store.data[short.ShortLink]; ok </span><span class="cov8" title="1">{
                                if record.UUID == short.UUID &amp;&amp; record.ShortLink == short.ShortLink </span><span class="cov8" title="1">{
                                        store.data[short.ShortLink].Deleted = true
                                }</span>
                        } else<span class="cov8" title="1"> {
                                return errors.New("key error")
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetStat - gets dtatistics of urls and users
func (store *InMemoryStore) GetStat() (*model.StatResponse, error) <span class="cov0" title="0">{
        result := new(model.StatResponse)

        return result, nil
}</span>

// NewInMemoryStore returns new store instance
func NewInMemoryStore() *InMemoryStore <span class="cov8" title="1">{
        store := &amp;InMemoryStore{
                data: make(map[string]*model.StoreRecord),
        }

        return store
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package mockstore

import (
        "github.com/alxrusinov/shorturl/internal/model"
        "github.com/stretchr/testify/mock"
)

const (
        indexZero = iota
        indexOne
)

// MockStore - store mockking real store
type MockStore struct {
        mock.Mock
}

// GetLink returns link from store
func (ms *MockStore) GetLink(arg *model.StoreRecord) (*model.StoreRecord, error) <span class="cov8" title="1">{
        args := ms.Called(arg)

        return args.Get(indexZero).(*model.StoreRecord), args.Error(indexOne)
}</span>

// SetLink adds link to store
func (ms *MockStore) SetLink(arg *model.StoreRecord) (*model.StoreRecord, error) <span class="cov8" title="1">{
        args := ms.Called(arg)

        return args.Get(indexZero).(*model.StoreRecord), args.Error(indexOne)
}</span>

// SetBatchLink adds links to store by batch
func (ms *MockStore) SetBatchLink(arg []*model.StoreRecord) ([]*model.StoreRecord, error) <span class="cov8" title="1">{
        args := ms.Called(arg)

        return args.Get(indexZero).([]*model.StoreRecord), args.Error(indexOne)
}</span>

// Ping pings store
func (ms *MockStore) Ping() error <span class="cov8" title="1">{
        args := ms.Called()

        return args.Error(0)
}</span>

// GetLinks returns all users links
func (ms *MockStore) GetLinks(userID string) ([]model.StoreRecord, error) <span class="cov8" title="1">{
        args := ms.Called(userID)

        return args.Get(indexZero).([]model.StoreRecord), args.Error(indexOne)
}</span>

// DeleteLinks deletes links by batch
func (ms *MockStore) DeleteLinks(shorts [][]model.StoreRecord) error <span class="cov8" title="1">{
        args := ms.Called(shorts)

        return args.Error(indexZero)
}</span>

// GetStat - gets dtatistics of urls and users
func (ms *MockStore) GetStat() (*model.StatResponse, error) <span class="cov8" title="1">{
        args := ms.Called()

        return args.Get(indexZero).(*model.StatResponse), args.Error(indexOne)
}</span>

// NewMockStore returns new mockestore instnce
func NewMockStore() *MockStore <span class="cov8" title="1">{
        return new(MockStore)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
